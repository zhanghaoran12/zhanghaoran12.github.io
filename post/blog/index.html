<!doctype html>
<html lang="zh-cn">
  <head>
    <title>swift学习笔记1 // 张浩然的个人博客</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.55.5" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://zhanghaoran12.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="swift学习笔记1"/>
<meta name="twitter:description" content="常量和变量 常量和变量必须在使用前声明，用 let 来声明常量，用 var 来声明变量。
let maximumNumberOfLoginAttempts = 10 var currentLoginAttempt = 0 var x = 0.0, y = 0.0, z = 0.0  类型标注 当你声明常量或者变量的时候可以加上类型标注（type annotation），说明常量或者变量中要存储的值的类型。
var welcomeMessage: String welcomeMessage = &quot;Hello&quot; var red, green, blue: Double  输出常量和变量 你可以用print(:separator:terminator:)函数来输出当前常量或变量的值: print(:separator:terminator:) 是一个用来输出一个或多个值到适当输出区的全局函数。如果你用 Xcode，print(_:separator:terminator:) 将会输出内容到“console”面板上。separator 和 terminator 参数具有默认值，因此你调用这个函数的时候可以忽略它们。默认情况下，该函数通过添加换行符来结束当前行。如果不想换行，可以传递一个空字符串给 terminator 参数&ndash;例如，print(someValue, terminator:&ldquo;&rdquo;) 。 Swift 用字符串插值（string interpolation）的方式把常量名或者变量名当做占位符加入到长字符串中，Swift 会用当前常量或变量的值替换这些占位符。将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义：
print(&quot;The current value of friendlyWelcome is \(friendlyWelcome)&quot;) // 输出 &quot;The current value of friendlyWelcome is Bonjour!"/>

    <meta property="og:title" content="swift学习笔记1" />
<meta property="og:description" content="常量和变量 常量和变量必须在使用前声明，用 let 来声明常量，用 var 来声明变量。
let maximumNumberOfLoginAttempts = 10 var currentLoginAttempt = 0 var x = 0.0, y = 0.0, z = 0.0  类型标注 当你声明常量或者变量的时候可以加上类型标注（type annotation），说明常量或者变量中要存储的值的类型。
var welcomeMessage: String welcomeMessage = &quot;Hello&quot; var red, green, blue: Double  输出常量和变量 你可以用print(:separator:terminator:)函数来输出当前常量或变量的值: print(:separator:terminator:) 是一个用来输出一个或多个值到适当输出区的全局函数。如果你用 Xcode，print(_:separator:terminator:) 将会输出内容到“console”面板上。separator 和 terminator 参数具有默认值，因此你调用这个函数的时候可以忽略它们。默认情况下，该函数通过添加换行符来结束当前行。如果不想换行，可以传递一个空字符串给 terminator 参数&ndash;例如，print(someValue, terminator:&ldquo;&rdquo;) 。 Swift 用字符串插值（string interpolation）的方式把常量名或者变量名当做占位符加入到长字符串中，Swift 会用当前常量或变量的值替换这些占位符。将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义：
print(&quot;The current value of friendlyWelcome is \(friendlyWelcome)&quot;) // 输出 &quot;The current value of friendlyWelcome is Bonjour!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhanghaoran12.github.io/post/blog/" />
<meta property="article:published_time" content="2019-05-10T20:07:59&#43;08:00"/>
<meta property="article:modified_time" content="2019-05-10T20:07:59&#43;08:00"/>


  </head>
  <body>
    <header class="app-header">
      <a href="https://zhanghaoran12.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="John Doe" /></a>
      <h1>张浩然的个人博客</h1>
      <p>又聪明 又厚道 又善良...</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/zhanghaoran12"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
          <a target="_blank" href="https://weibo.com/3192022912/profile"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-link">
  <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
  <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">swift学习笔记1</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          May 10, 2019
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          4 min read
        </div></div>
    </header>
    <div class="post-content">
      

<h3 id="常量和变量">常量和变量</h3>

<p>常量和变量必须在使用前声明，用 let 来声明常量，用 var 来声明变量。</p>

<pre><code>let maximumNumberOfLoginAttempts = 10
var currentLoginAttempt = 0
var x = 0.0, y = 0.0, z = 0.0
</code></pre>

<h3 id="类型标注">类型标注</h3>

<p>当你声明常量或者变量的时候可以加上类型标注（type annotation），说明常量或者变量中要存储的值的类型。</p>

<pre><code>var welcomeMessage: String
welcomeMessage = &quot;Hello&quot;
var red, green, blue: Double
</code></pre>

<h3 id="输出常量和变量">输出常量和变量</h3>

<p>你可以用print(<em>:separator:terminator:)函数来输出当前常量或变量的值:
print(</em>:separator:terminator:) 是一个用来输出一个或多个值到适当输出区的全局函数。如果你用 Xcode，print(_:separator:terminator:) 将会输出内容到“console”面板上。separator 和 terminator 参数具有默认值，因此你调用这个函数的时候可以忽略它们。默认情况下，该函数通过添加换行符来结束当前行。如果不想换行，可以传递一个空字符串给 terminator 参数&ndash;例如，print(someValue, terminator:&ldquo;&rdquo;) 。
Swift 用字符串插值（string interpolation）的方式把常量名或者变量名当做占位符加入到长字符串中，Swift 会用当前常量或变量的值替换这些占位符。将常量或变量名放入圆括号中，并在开括号前使用反斜杠将其转义：</p>

<pre><code>print(&quot;The current value of friendlyWelcome is \(friendlyWelcome)&quot;)
// 输出 &quot;The current value of friendlyWelcome is Bonjour!
</code></pre>

<h3 id="元组">元组</h3>

<p>元组（tuples）把多个值组合成一个复合值。元组内的值可以是任意类型，并不要求是相同类型。</p>

<p>下面这个例子中，(404, &ldquo;Not Found&rdquo;) 是一个描述 HTTP 状态码（HTTP status code）的元组。HTTP 状态码是当你请求网页的时候 web 服务器返回的一个特殊值。如果你请求的网页不存在就会返回一个 404 Not Found 状态码。</p>

<pre><code>let http404Error = (404, &quot;Not Found&quot;)
// http404Error 的类型是 (Int, String)，值是 (404, &quot;Not Found&quot;)
</code></pre>

<p>(404, &ldquo;Not Found&rdquo;) 元组把一个 Int 值和一个 String 值组合起来表示 HTTP 状态码的两个部分：一个数字和一个人类可读的描述。这个元组可以被描述为“一个类型为 (Int, String) 的元组”。</p>

<p>你可以把任意顺序的类型组合成一个元组，这个元组可以包含所有类型。只要你想，你可以创建一个类型为  (Int, Int, Int) 或者 (String, Bool) 或者其他任何你想要的组合的元组。</p>

<p>你可以将一个元组的内容分解（decompose）成单独的常量和变量，然后你就可以正常使用它们了：</p>

<pre><code>let (statusCode, statusMessage) = http404Error
print(&quot;The status code is \(statusCode)&quot;)
// 输出 &quot;The status code is 404&quot;
print(&quot;The status message is \(statusMessage)&quot;)
// 输出 &quot;The status message is Not Found&quot;
</code></pre>

<p>如果你只需要一部分元组值，分解的时候可以把要忽略的部分用下划线（_）标记：</p>

<pre><code>let (justTheStatusCode, _) = http404Error
print(&quot;The status code is \(justTheStatusCode)&quot;)
// 输出 &quot;The status code is 404&quot;
</code></pre>

<p>此外，你还可以通过下标来访问元组中的单个元素，下标从零开始：</p>

<pre><code>print(&quot;The status code is \(http404Error.0)&quot;)
// 输出 &quot;The status code is 404&quot;
print(&quot;The status message is \(http404Error.1)&quot;)
// 输出 &quot;The status message is Not Found&quot;
</code></pre>

<p>你可以在定义元组的时候给单个元素命名：</p>

<pre><code>let http200Status = (statusCode: 200, description: &quot;OK&quot;)
</code></pre>

<p>给元组中的元素命名后，你可以通过名字来获取这些元素的值：</p>

<pre><code>print(&quot;The status code is \(http200Status.statusCode)&quot;)
// 输出 &quot;The status code is 200&quot;
print(&quot;The status message is \(http200Status.description)&quot;)
// 输出 &quot;The status message is OK&quot;
</code></pre>

<p>作为函数返回值时，元组非常有用。一个用来获取网页的函数可能会返回一个 (Int, String) 元组来描述是否获取成功。和只能返回一个类型的值比较起来，一个包含两个不同类型值的元组可以让函数的返回信息更有用。</p>

<h3 id="可选类型">可选类型</h3>

<p>使用可选类型（optionals）来处理值可能缺失的情况。</p>

<p>Swift 的 Int 类型有一种构造器，作用是将一个 String 值转换成一个 Int 值。然而，并不是所有的字符串都可以转换成一个整数。字符串 &ldquo;123&rdquo; 可以被转换成数字 123 ，但是字符串 &ldquo;hello, world&rdquo; 不行。</p>

<p>下面的例子使用这种构造器来尝试将一个 String 转换成 Int：</p>

<pre><code>let possibleNumber = &quot;123&quot;
let convertedNumber = Int(possibleNumber)
// convertedNumber 被推测为类型 &quot;Int?&quot;， 或者类型 &quot;optional Int&quot;
</code></pre>

<p>因为该构造器可能会失败，所以它返回一个可选类型（optional）Int，而不是一个 Int。一个可选的 Int 被写作  Int? 而不是 Int。问号暗示包含的值是可选类型，也就是说可能包含 Int 值也可能不包含值。（不能包含其他任何值比如 Bool 值或者 String 值。只能是 Int 或者什么都没有。）</p>

<h3 id="nil">nil</h3>

<p>你可以给可选变量赋值为nil来表示它没有值：</p>

<pre><code>var serverResponseCode: Int? = 404
// serverResponseCode 包含一个可选的 Int 值 404
serverResponseCode = nil
// serverResponseCode 现在不包含值
</code></pre>

<blockquote>
<p>注意：
nil不能用于非可选的常量和变量。如果你的代码中有常量或者变量需要处理值缺失的情况，请把它们声明成对应的可选类型。
如果你声明一个可选常量或者变量但是没有赋值，它们会自动被设置为 nil：</p>
</blockquote>

<pre><code>var surveyAnswer: String?
// surveyAnswer 被自动设置为 nil
</code></pre>

<h3 id="可选绑定">可选绑定</h3>

<p>使用可选绑定（optional binding）来判断可选类型是否包含值，如果包含就把值赋给一个临时常量或者变量。可选绑定可以用在 if 和 while 语句中，这条语句不仅可以用来判断可选类型中是否有值，同时可以将可选类型中的值赋给一个常量或者变量。</p>

<pre><code>if let constantName = someOptional {
    statements
}
</code></pre>

<p>你可以像上面这样使用可选绑定来重写 possibleNumber 这个例子：</p>

<pre><code>if let actualNumber = Int(possibleNumber) {
    print(&quot;\'\(possibleNumber)\' has an integer value of \(actualNumber)&quot;)
} else {
    print(&quot;\'\(possibleNumber)\' could not be converted to an integer&quot;)
}
// 输出 &quot;'123' has an integer value of 123&quot;
</code></pre>

<p>这段代码可以被理解为：</p>

<p>“如果 Int(possibleNumber) 返回的可选 Int 包含一个值，创建一个叫做 actualNumber 的新常量并将可选包含的值赋给它。”</p>

<p>如果转换成功，actualNumber 常量可以在 if 语句的第一个分支中使用。它已经被可选类型 包含的 值初始化过，所以不需要再使用 ! 后缀来获取它的值。在这个例子中，actualNumber 只被用来输出转换结果。</p>

<p>你可以在可选绑定中使用常量和变量。如果你想在if语句的第一个分支中操作 actualNumber 的值，你可以改成  if var actualNumber，这样可选类型包含的值就会被赋给一个变量而非常量。</p>

<p>你可以包含多个可选绑定或多个布尔条件在一个 if 语句中，只要使用逗号分开就行。只要有任意一个可选绑定的值为nil，或者任意一个布尔条件为false，则整个if条件判断为false，这时你就需要使用嵌套 if 条件语句来处理，如下所示：</p>

<pre><code>if let firstNumber = Int(&quot;4&quot;), let secondNumber = Int(&quot;42&quot;), firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 {
    print(&quot;\(firstNumber) &lt; \(secondNumber) &lt; 100&quot;)
}
// 输出 &quot;4 &lt; 42 &lt; 100&quot;

if let firstNumber = Int(&quot;4&quot;) {
    if let secondNumber = Int(&quot;42&quot;) {
        if firstNumber &lt; secondNumber &amp;&amp; secondNumber &lt; 100 {
            print(&quot;\(firstNumber) &lt; \(secondNumber) &lt; 100&quot;)
        }
    }
}
// 输出 &quot;4 &lt; 42 &lt; 100&quot;
</code></pre>

<h3 id="隐式解析可选类型">隐式解析可选类型</h3>

<p>如上所述，可选类型暗示了常量或者变量可以“没有值”。可选可以通过 if 语句来判断是否有值，如果有值的话可以通过可选绑定来解析值。</p>

<p>有时候在程序架构中，第一次被赋值之后，可以确定一个可选类型总会有值。在这种情况下，每次都要判断和解析可选值是非常低效的，因为可以确定它总会有值。</p>

<p>这种类型的可选状态被定义为隐式解析可选类型（implicitly unwrapped optionals）。把想要用作可选的类型的后面的问号（String?）改成感叹号（String!）来声明一个隐式解析可选类型。</p>

<p>当可选类型被第一次赋值之后就可以确定之后一直有值的时候，隐式解析可选类型非常有用。隐式解析可选类型主要被用在 Swift 中类的构造过程中，</p>

<p>一个隐式解析可选类型其实就是一个普通的可选类型，但是可以被当做非可选类型来使用，并不需要每次都使用解析来获取可选值。下面的例子展示了可选类型 String 和隐式解析可选类型 String 之间的区别：</p>

<pre><code>let possibleString: String? = &quot;An optional string.&quot;
let forcedString: String = possibleString! // 需要感叹号来获取值

let assumedString: String! = &quot;An implicitly unwrapped optional string.&quot;
let implicitString: String = assumedString  // 不需要感叹号
</code></pre>

<p>你可以把隐式解析可选类型当做一个可以自动解析的可选类型。你要做的只是声明的时候把感叹号放到类型的结尾，而不是每次取值的可选名字的结尾。
&gt; 注意：
如果你在隐式解析可选类型没有值的时候尝试取值，会触发运行时错误。和你在没有值的普通可选类型后面加一个惊叹号一样。</p>

<p>你仍然可以把隐式解析可选类型当做普通可选类型来判断它是否包含值：</p>

<pre><code>if assumedString != nil {
    print(assumedString)
}
// 输出 &quot;An implicitly unwrapped optional string.&quot;
</code></pre>

<p>你也可以在可选绑定中使用隐式解析可选类型来检查并解析它的值：</p>

<pre><code>if let definiteString = assumedString {
    print(definiteString)
}
// 输出 &quot;An implicitly unwrapped optional string.&quot;
</code></pre>

<blockquote>
<p>注意：
如果一个变量之后可能变成nil的话请不要使用隐式解析可选类型。如果你需要在变量的生命周期中判断是否是nil的话，请使用普通可选类型。</p>

<h3 id="错误处理">错误处理</h3>

<p>你可以使用 错误处理（error handling） 来应对程序执行中可能会遇到的错误条件。</p>
</blockquote>

<p>相对于可选中运用值的存在与缺失来表达函数的成功与失败，错误处理可以推断失败的原因，并传播至程序的其他部分。</p>

<p>当一个函数遇到错误条件，它能报错。调用函数的地方能抛出错误消息并合理处理。</p>

<pre><code>func canThrowAnError() throws {
    // 这个函数有可能抛出错误
}
</code></pre>

<p>一个函数可以通过在声明中添加throws关键词来抛出错误消息。当你的函数能抛出错误消息时, 你应该在表达式中前置try关键词。</p>

<pre><code>do {
    try canThrowAnError()
    // 没有错误消息抛出
} catch {
    // 有一个错误消息抛出
}
</code></pre>

<p>一个do语句创建了一个新的包含作用域,使得错误能被传播到一个或多个catch从句。</p>

<p>这里有一个错误处理如何用来应对不同错误条件的例子。</p>

<pre><code>func makeASandwich() throws {
    // ...
}

do {
    try makeASandwich()
    eatASandwich()
} catch SandwichError.outOfCleanDishes {
    washDishes()
} catch SandwichError.missingIngredients(let ingredients) {
    buyGroceries(ingredients)
}
</code></pre>

<p>在此例中，makeASandwich()（做一个三明治）函数会抛出一个错误消息如果没有干净的盘子或者某个原料缺失。因为 makeASandwich() 抛出错误，函数调用被包裹在 try 表达式中。将函数包裹在一个 do 语句中，任何被抛出的错误会被传播到提供的 catch 从句中。</p>

<p>如果没有错误被抛出，eatASandwich() 函数会被调用。如果一个匹配 SandwichError.outOfCleanDishes 的错误被抛出，washDishes() 函数会被调用。如果一个匹配 SandwichError.missingIngredients 的错误被抛出，buyGroceries(_:) 函数会被调用，并且使用 catch 所捕捉到的关联值 [String] 作为参数。</p>

<h3 id="断言和先决条件">断言和先决条件</h3>

<p>断言和先决条件是在运行时所做的检查。你可以用他们来检查在执行后续代码之前是否一个必要的条件已经被满足了。如果断言或者先决条件中的布尔条件评估的结果为 true（真），则代码像往常一样继续执行。如果布尔条件评估结果为false（假），程序的当前状态是无效的，则代码执行结束，应用程序中止。</p>

<p>你使用断言和先决条件来表达你所做的假设和你在编码时候的期望。你可以将这些包含在你的代码中。断言帮助你在开发阶段找到错误和不正确的假设，先决条件帮助你在生产环境中探测到存在的问题。</p>

<p>除了在运行时验证你的期望值，断言和先决条件也变成了一个在你的代码中的有用的文档形式。和在上面讨论过的错误处理不同，断言和先决条件并不是用来处理可以恢复的或者可预期的错误。因为一个断言失败表明了程序正处于一个无效的状态，没有办法去捕获一个失败的断言。</p>

<p>使用断言和先决条件不是一个能够避免出现程序出现无效状态的编码方法。然而，如果一个无效状态程序产生了，断言和先决条件可以强制检查你的数据和程序状态，使得你的程序可预测的中止（译者：不是系统强制的，被动的中止），并帮助使这个问题更容易调试。一旦探测到无效的状态，执行则被中止，防止无效的状态导致的进一步对于系统的伤害。</p>

<p>断言和先决条件的不同点是，他们什么时候进行状态检测：断言仅在调试环境运行，而先决条件则在调试环境和生产环境中运行。在生产环境中，断言的条件将不会进行评估。这个意味着你可以使用很多断言在你的开发阶段，但是这些断言在生产环境中不会产生任何影响。</p>

<h4 id="使用断言进行调试">使用断言进行调试</h4>

<p>你可以调用 Swift 标准库的 assert(<em>:</em>:file:line:) 函数来写一个断言。向这个函数传入一个结果为 true 或者  false 的表达式以及一条信息，当表达式的结果为 false 的时候这条信息会被显示：</p>

<pre><code>let age = -3
assert(age &gt;= 0, &quot;A person's age cannot be less than zero&quot;)
// 因为 age &lt; 0，所以断言会触发
</code></pre>

<p>在这个例子中，只有 age &gt;= 0 为 true 时，即 age 的值非负的时候，代码才会继续执行。如果 age 的值是负数，就像代码中那样，age &gt;= 0 为 false，断言被触发，终止应用。</p>

<p>如果不需要断言信息，可以就像这样忽略掉：</p>

<pre><code>assert(age &gt;= 0)
</code></pre>

<p>如果代码已经检查了条件，你可以使用 assertionFailure(_:file:line:)函数来表明断言失败了，例如：</p>

<pre><code>if age &gt; 10 {
    print(&quot;You can ride the roller-coaster or the ferris wheel.&quot;)
} else if age &gt; 0 {
    print(&quot;You can ride the ferris wheel.&quot;)
} else {
    assertionFailure(&quot;A person's age can't be less than zero.&quot;)
}
</code></pre>

<h4 id="强制执行先决条件">强制执行先决条件</h4>

<p>当一个条件可能为false（假），但是继续执行代码要求条件必须为true（真）的时候，需要使用先决条件。例如使用先决条件来检查是否下标越界，或者来检查是否将一个正确的参数传给函数。</p>

<p>你可以使用全局 precondition(<em>:</em>:file:line:) 函数来写一个先决条件。向这个函数传入一个结果为 true 或者  false 的表达式以及一条信息，当表达式的结果为 false 的时候这条信息会被显示：</p>

<pre><code>// 在一个下标的实现里...
precondition(index &gt; 0, &quot;Index must be greater than zero.&quot;)
</code></pre>

<p>你可以调用　precondition(<em>:</em>:file:line:)方法来表明出现了一个错误，例如，switch 进入了 default 分支，但是所有的有效值应该被任意一个其他分支（非 default 分支）处理。
&gt; 注意：
如果你使用unchecked模式（-Ounchecked）编译代码，先决条件将不会进行检查。编译器假设所有的先决条件总是为true（真），他将优化你的代码。然而，fatalError(<em>:file:line:)函数总是中断执行，无论你怎么进行优化设定。
你能使用 fatalError(</em>:file:line:)函数在设计原型和早期开发阶段，这个阶段只有方法的声明，但是没有具体实现，你可以在方法体中写上fatalError(&ldquo;Unimplemented&rdquo;)作为具体实现。因为fatalError不会像断言和先决条件那样被优化掉，所以你可以确保当代码执行到一个没有被实现的方法时，程序会被中断。</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
